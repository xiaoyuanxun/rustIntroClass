# 所有权
所有权就是对资源拥有的权利。
所有权的三条定义：
- Rust中，每一个值（资源）都有一个所有者
- 任何一个时刻，一个值只有一个所有者
- 当所有者所在作用域结束时,值将被释放

两个概念：
- 所有者：在代码中，就表示为变量
- 作用域：变量有效的那个区间

RAII: 堆内存资源随着关联的栈上局部变量一起被回收的内存管理特性
## 使用所有权书写函数
```rust
fn foo(s: String) -> String {
    println!("{s}");
    s
}

fn main() {
    let s1 = String::from("I am a superman.");
    let s2 = foo(s1);
    
    println!("{s2}");
}
```
## 移动还是复制
对于变量的绑定，默认做复制操作的：
- 所有的整数类型，比如u32
- 布尔类型，bool
- 浮点数类型：f32, f64
- 字符类型 char
- 由以上类型组成的元组类型Tuple，如（i32, f32, char）

其他类型，默认做值的移动操作
## 借用与引用
借用和引用是一体两面，对同一个事情的两个面的描述。

你把东西借给别人，也就是别人持有了对你这个东西的引用。

借用是站在资源拥有者角度来说的，引用是站在想借这个资源的变量角度来说的。

引用的用法：在变量前用“&”符合来表示，例如 &x 

引用也是一种值，并且是固定长度的值(和计算机架构相关)
```rust
let b = &a; // b 引用 a

let c = b; // 将 b 复制给 c  引用的复制
```
# 不可变引用与可变引用
- 引用包含不可变引用和可变引用
- &x 对变量x的不可变引用
- &mut x 对变量x的可变引用

为什么存在可变引用：既是一种引用，又能够修改指向的那个值

例子
```rust
let mut a = 10u32;
let b = &mut a; // 可变引用
*b = 20; // 解引用

println!("{b}");
```

引用的调用时机很关键

- 一个拥有所有权的变量的作用域是从它定义时到花括号结束
- **引用的作用域是从它定义到它最后一次使用时结束**

如果它定义了但未被使用，那么它的作用域是有它定义的那一行，出生即死亡

一个资源的可变引用与不可变引用的作用域不能交叠

prinln!("a") 会对a不可变引用

引用（借用）规则：
- 引用（不可变引用和可变引用都是）变量的作用域不会长于所有权的作用域。
- 一个资源的可变引用与不可变引用的作用域不能交叠
- 某个时刻对某个资源只能存在一个可变引用，不能有超过一个可变引用同时存在
- 一个资源的不可变引用，可以同时存在多个，即不可变引用间可以交叠

## 可变引用的排他性
即可变引用不能被复制
```rust
fn main() {
    let mut a = 10u32;
    let r1 = &mut a;
    let r2 = r1; // -- value moved here

    println!("{r1}"); // 报错value borrowed here after move
}
```
- 不可变引用可以被复制
- 可变引用不能被复制，只能被move

## 用&和& mut来改进函数的定义
```rust
fn foo(s: &String) {
    println!("in fn foo: {s}");
}

fn main() {
    let s1 = String::from("I am a superman.");
    foo(&s1);
    println!("{s1}");
}
```

```rust
fn foo(s: &mut String) {
    s.push_str(" You are batman.");
}

fn main() {
    let mut s1 = String::from("I am a superman.");
    println!("{s1}");
    foo(&mut s1);
    println!("{s1}");
}
```
如果一个函数参数接受的是可变引用，或所有权参数，那么其代码逻辑一般会对引用的资源进行修改；

如果一个参数只接受不可变引用，那么其逻辑就一定不会修改被引用的资源；

这样使得代码结构逻辑清晰。